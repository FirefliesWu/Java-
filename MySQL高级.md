# MySQL 高级

---

## Explain

+ id
+ Select_type
+ table
+ type
+ Possible_keys
+ key
+ key_len
+ ref
+ rows
+ Extra

### 关键字

|    关键字     | 描述                                                         |
| :-----------: | :----------------------------------------------------------- |
|      id       | 查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序<br/>**两种情况**<br/>id相同，执行顺序从上往下<br/>id不同，id值越大，优先级越高，越先执行 |
|  select_type  | 查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询<br/>1、simple ——简单的select查询，查询中不包含子查询或者UNION<br/>2、primary ——查询中若包含任何复杂的子部分，最外层查询被标记<br/>3、subquery——在select或where列表中包含了子查询<br/>4、derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中<br/>5、union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived<br/>6、union result:UNION 的结果 |
|     table     | 输出的行所用的表                                             |
|     type      | 显示联结类型，显示查询使用了何种类型，按照从最佳到最坏类型排序<br/>1、system：表中仅有一行（=系统表）这是const联结类型的一个特例。<br/>2、const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量<br/>3、eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描<br/>4、ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体<br/>5、range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描<br/>6、index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。<br/>7、all：遍历全表以找到匹配的行<br/>注意:一般保证查询至少达到range级别，最好能达到ref。 |
|      key      | 显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。 |
|    key_len    | 表示索引中使用的字节数，该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。 |
|      ref      | 显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值 |
|     rows      | 根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数 |
|     extra     | 包含不适合在其他列中显示，但是十分重要的额外信息<br/>1、Using filesort：说明mysql会对数据适用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作称为“文件排序”<br/>2、Using temporary:使用了临时表保存中间结果，mysql在查询结果排序时使用临时表。常见于排序order by和分组查询group by。<br/>3、Using index:表示相应的select操作用使用覆盖索引，避免访问了表的数据行。如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引用来读取数据而非执行查询动作。<br/>4、Using where :表明使用where过滤<br/>5、using join buffer:使用了连接缓存<br/>6、impossible where:where子句的值总是false，不能用来获取任何元组<br/>7、select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。<br/>8、distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。 |
| possible_keys | 指出MYSQL能使用哪个索引在该表中找到行                        |

---

## 锁

+ 读锁会阻塞写，写锁会阻塞读
+ 共享锁写法： lock in share mode    
  + 例如：select math from hdu where math > 60 lock in share mode
+ 排他锁写法： for update
  + 例如：select math from hdu where math > 60 for update
  + insert, delete, update 在事务中会自动默认加上排他锁
+ Myisam的读写锁调度是**写优先**，这也是myisam不适合做写为主表的原因，写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞
+ InnoDB和MyISAM的最大不同：<u>1 支持事务  2 行级锁</u>
+ 事务四大特性：ACID —— **原子性、一致性、隔离性、持久性**
+ varchar类型不加单引号，可能由于自动类型转换导致**索引失效、行级锁升级为表锁**
+ 间隙锁：当使用范围条件而不是相等条件检索数据，请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（gap）”，间隙也会被加锁，这种锁机制叫做间隙锁（Next-Key锁）

#### 行锁和表锁

+ 表锁：不会出现死锁，发生锁冲突的概率高，并发度低
+ 行锁：会出现死锁，发生锁冲突几率低，并发度高

**锁冲突：**例如事务 A 给某几行上锁，事务 B 又对其上锁，**锁不能共存否则会出现锁冲突**。（共享锁可以共存，共享锁和排他锁不能共存，排他锁和排他锁也不能共存）

### 悲观锁和乐观锁

+ 悲观锁：假设数据肯定会冲突，在数据开始读取时候就将数据锁定。
+ 乐观锁：认为数据一般不会冲突，在数据进行提交更新的时候才正式对数据冲突与否进行检测，如果发现冲突，则让用户返回错误的信息让用户决定如何去做。
  + 具体实现：表中有一个版本字段，第一次读的时候读取这个字段，处理完业务逻辑开始更新的时候在此查看该字段是否和第一次一样，一样则更新，否则拒绝。

实现方式对比：

+ 悲观锁：大多基于数据库的锁机制实现：排他锁 - select for update
+ 乐观锁：大多基于数据版本记录机制实现，可通过给表加一个版本号或者时间戳字段，每次更新的时候对比当前版本和提取时的版本是否相等。

---

### 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  是  |     是     |  是  |
| 读已提交 |  否  |     是     |  是  |
| 可重复读 |  否  |     否     |  是  |
| 串行化读 |  否  |     否     |  否  |

+ 脏读：事务A 读到了 事务B未提交的数据，事务B进行回滚操作。
  + 解决：读取时加共享锁，修改时加排他锁
+ 不可重复度：事务A 多次读取同一个数据，事务B在该过程中，对数据进行了更新并提交，导致事务A多次读取同一个数据时，结果不一致。
+ 幻读：A事务 读取了 B事务已经提交的 **新增（删除）数据**。同一事务中，同样操作读取到的记录数不同。
  + 解决：读取时加共享锁，写数据时加排他锁，事务提交后才释放锁。

#### 当前读和快照读

+ 当前读：读取的是最新版本
  + update \ delete \ insert \ select ... lock in share mode \ select ... for update 是当前读
+ 快照读：读取的是历史版本，普通的 select 就是快照读
  + Read Committed 隔离级别：每次 select 生成一个快照读
  + Read Reapeatable 隔离级别：开启事务后第一个 select 才快照读

---

## MVCC 多版本并发控制

+ 原理：在每一行记录后面增加了两个隐藏列，记录创建版本号的删除版本号。每个事务开启都会有唯一的递增版本号，被操作的数据会生成一条新的数据行（临时），但在提交前对其他事务是不可见的，对于数据的更新成果，会将该笨笨好更新到数据的行中，事务提交成功，将新的版本号更新到该数据行中。

+ MVCC 的最大好处在于：读不加锁，读写不冲突。极大增加了系统的并发性。InnoDB采用的是行级锁，并且采用了多版本并发控制来提高读操作的性能。

### MVCC 在 InnoDB 中的实现

+ select 操作：
  + 只查找版本早于或等于当前事务版本的数据行
  + 行的删除版本要么未定义，要么大于当前事务版本号

+ insert 操作：将新插入的行保存当前版本号为行版本号
+ delete 操作： 将删除的行保存当前版本号为删除版本号
+ update 操作：insert 的行保存当前版本号，delete 保存当前版本号到原来行的删除版本号

由于旧数据并不是真正的删除，所以 InnoDB 会开启一个后台线程执行清理工作，删除删除版本号小于当前版本的行，这个过程叫做 purge 。

---

## 索引结构

| InnoDB |  MyISAM  | Memory |
| :----: | :------: | :----: |
| B+Tree | Fulltext |  Hash  |

+ B 树：有序数组 + 平衡多叉树
+ B+ 树：有序数组链表 + 平衡多叉树

B+ 树(叶节点保存数据，其他的节点 全部存放索引)，数据库索引采用 B+ 树的主要原因是： <u>B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题</u>。正是为了解决这个问题，B+ 树应运而生。 <u>B+ 树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）</u>。另一方面，**由于 B+ 树把数据项都储存在叶子节点，数据项占的空间小，数量增加，树的高度降低，减少 IO 次数**。

### 为什么平衡二叉树（或红黑树）不适合作为索引？

**索引是存在于索引文件中，是存在于磁盘中的**。因为索引通常很大，因此无法一次将全部索引加载到内存中，因此每次只能从磁盘中读取一个磁盘页的数据到内存中。而磁盘读取速度比内存读取速度满了很多。**因此，适合作为索引的结构应当尽可能减少磁盘 IO 操作，因为执行磁盘 IO 操作非常耗时。**

## 索引数据类型的选择

+ 越小的数据类型通常越好
+ 简单的数据类型更好
+ 尽量避免 NULL：应该制定列为 NOT NULL

## MySQL 常见索引

**应遵循“最左前缀”原则**

+ INDEX （普通索引）
+ UNIQUE （唯一索引）
  + 索引列的值必须唯一，允许空值
+ PRIMARY KEY （主键索引）
  + 不能有空值
+ FULLTEXT （全文索引）
  + 仅可用于 MyISAM 和 InnoDB，针对较大的数据，生成全文索引很耗时间和空间
+ 组合索引
  + ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')

## 索引 B+ 树的叶子节点都可以存哪些东西（或问聚簇索引与非聚簇索引的区别？

可能存储整行数据，也有可能是主键的值。
***\*B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引\****。而***\*索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引\****。

+ 聚蔟索引

  所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引。

+ 非聚蔟索引

  非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的，主要用在MyISAM存储引擎中。非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。

+ 覆盖索引

  指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

  

**注意：**

**MySQL InnoDB一定会建立聚簇索引，把实际数据行和相关的键值保存在一块，这也决定了一个表只能有一个聚簇索引**，即MySQL不会一次把数据行保存在二个地方。

+ InnoDB通常根据主键值(primary key)进行聚簇
+ 如果没有创建主键，则会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
+ 上面二个条件都不满足，InnoDB会自己创建一个虚拟的聚集索引
+ 正因为InnoDB将数据保存在一处，因此其插入速度严重依赖插入顺序。按照主键顺序插入无疑是最快的。如果不是按照主键插入，建议加载完成后最好使用OPTIMIZE TABLE重新组织一下表。

---

## SQL 优化

### 查询在什么时候不走（预期中的）索引 ？

+ Order by 和 limit 结合使用，遇到此类状况可以考虑用子查询将order by 和 limit 分开。
+ DATE_FORMAT()  格式化时间，格式化后的时间再去比较，可能会导致索引失效。
+ **子查询中 order by 的索引会失效，同时可能导致子查询中的 where 条件索引都不能用。**
+ 字符集的使用导致不走索引
+ like 语句
+ 列类型为字符串类型，查询时没有用单引号引起来
+ 在 where 查询语句中使用表达式
+ 在 where 查询语句中对字段进行 NULL 值判断
+ 在 where 查询中使用了 or 关键字，Myisam 表能用到索引，InnoDB 不行；（用 UNION 替换 or ，可以使用索引）
+ 全表扫描快于索引扫描（数据量小时）



### SQL 如何优化

+ 创建并使用正确的索引
+ 只返回需要的字段
+ 减少交互次数（批量提交）
+ 设置合理的 Fetch Size （数据每次返回给客户端的条数）

> https://blog.csdn.net/xiaofeng10330111/article/details/105361002

### SQL 执行顺序

+ **from -> where -> group by -> having -> select -> order by**

### 一条 SQL 的执行过程

+ 第一步：连接器（与客户端建立连接、获取权限、维持和管理连接）
+ 第二步：查询缓存
  + 之前执行的查询，MYSQL 以键值对的方式存在内存（K为SQL，V为结果集）
  + 只有该表有更新，则这个表的查询缓存被清空
  + 手动创建命令：MYSQL8已经移除   select SQL_CACHE * from T
+ 第三步：分析器（词法、语法分析）
  + 词法分析：select -> 查询；识别表名等等。
  + 语法分析
+ 第四步：优化器
  + 决定用哪个索引；联查表连接顺序；条件执行优先级等等
+ 第五步：执行器
+ 第六步：存储引擎（提供读写接口，供执行器调用获取结果集）
  + 先判断是否有该权限
  + 如果命中缓存，则会在返回结果的时候进行权限验证

### Order by 优化

+ 给 order by 加索引，order by 的字段必须在最前面设置
+ 去掉不必要的返回字段
+ 增大 sort_buffer_size 参数

---

## binlog, redolog, undolog 都是什么，起什么作用

+ undolog

  回滚日志文件，主要用于事务中执行失败，进行回滚，以及 MVCC 中对于数据历史版本的查看。当事务提交之后，undo log 并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应 undolog 。

+ redolog

  重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。

+ binlog

  由 Mysql 的 Server 层实现，是逻辑日志，记录的是sql语句的原始逻辑，用于复制和恢复在主从复制中，从库利用主库上的 binlog 进行重播(执行日志中记录的修改逻辑),实现主从同步。业务数据不一致或者错了，用 binlog 恢复。

---

## MyISAM 和 InnoDB 的区别，选择

**基本区别：存储结构、存储空间、事务支持、CRUD操作、外键**

存储结构：

+ MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义。数据文件的扩展名为.MYD(MYD)。索引文件的扩展名是.MYI(MYIndex)。
+ InnoDB:所在的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

存储空间：

+ MyISAM: 可被压缩，存储空间较小。支持三种不同的存储格式：静态表（默认，但是注意数据末尾不能有空格，会被去掉）、动态表、压缩表。
+ InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

事务支持：

+ MyISAM：强调性能，每次查询具有原子性，不支持事务。执行速度比 InnoDB快。
+ InnoDB：支持事务，外键等功能。事务安全型表

CRUD 操作：

+ MyISAM：如果大量查询，MyISAM更好。但是由于没有行锁，增删的时候要锁定整张表，效率低。
+ InnoDB：如果大量增删改，InnoDB更好。可以用行锁锁定需要修改的行，效率高。delete 时 InnoDB 不会重新建表，而是一行一行删除，因此要清空保存大量数据的表，应当使用 truncate table 命令。

外键：

+ MyISAM：不支持
+ InnoDB: 支持

#### 选择

因为 MyISAM 相对简单，效率优于 InnoDB。如果读多写少，对原子性要求低，那么 MyISAM 更好，恢复速度快，可直接用备份覆盖恢复。

如果写多读少，尤其是并发写入高的时候，应当选择 InnoDB。

---

## truncate、drop 和 delete 对比

+ truncate 和 drop 是 DDL 语句，不可回滚，delete 是 DML 语句，可回滚。

+ truncate 只能作用于表，delete 和 drop 可作用于表、视图等。
+ truncate 会清空表中所有行，但表结构和约束、索引等保持不变；drop 会删除表结构、约束和索引等。
+ truncate 会重置表的自增值，delete 不会
+ truncate 不会激活与表有关的删除触发器；delete 会
+ truncate 会让表和索引所占空间恢复到初始大小；delete 不会减少表或索引占的空间，drop 将表占用的空间全部释放。







