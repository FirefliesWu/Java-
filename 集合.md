# 集合

---

[TOC]

---

**集合和数组的区别**

+ 数组是固定长度的，集合长度可变
+ 集合只能存引用数据类型，数组既能存基本数据类型，也可以存引用数据类型
+ 数组存储的元素必须相同数据类型；集合存储对象可以不同数据类型

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc?x-oss-process=image/format,png)

Collection 集合主要有 List 和 Set 两大接口：

+ List：有序（存入和取出的顺序一致），元素可重复，可插入多个 null 元素，元素都有索引。
  + 实现类：ArrayList、LinkedList、Vector
+ Set：无序，元素不可重复，只能存一个 null，元素唯一性。
  + 实现类：HashSet、LinkedHashSet 和 TreeSet

Map 是一个键值对集合，Key 无序唯一，Value 可重复。

​	Map 实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap

---

## 集合底层数据结构

Collection

+ List
  + Arraylist： Object数组
  + Vector： Object数组
  + LinkedList： 双向循环链表
+ Set
  + HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素
  + LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。
  + TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)
+ Map
  + HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间
  + LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
  + HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的
  + TreeMap： 红黑树（自平衡的排序二叉树）

---

## 线程安全的集合类

+ vector：就比 arrayList 多了个同步化机制（线程安全），效率较低，不建议使用
+ stack：堆栈类，先进后出
+ hashTable：就比 hashMap 多了个线程安全
+ enumeration：枚举，相当于迭代器

## Java 集合的快速失败机制“Fail-fast”

当多个线程对集合进行结构上的改变的操作时，有可能产生 fail-fast 机制。

例如：线程 A 通过 Iterator 遍历集合 1 的元素，线程 B 修改了 1 的结构，就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。

**原因**：迭代器在遍历时会使用一个 modCount 变量。如果集合在遍历期间内容发生改变，modCount 的值就会改变。每当迭代器遍历下一个元素之前会检查 modCount，如果变了就会抛出异常，终止遍历。

**解决方法**：

1. 在遍历过程中，所有涉及改变 modCount 的地方全部加上 synchronized。
2. 使用 CopyOnWriteArrayList 替代 ArrayList。

### CopyOnWriteArrayList

支持高效率并发且线程安全，读操作无锁。因为所有可变操作都是通过对底层数组进行一次新的复制来实现，因此写不会影响读。

+ 使用场景：读操作远远大于写操作的场景，如缓存。
+ 缺点：每次写操作都要复制一个副本，需要消耗内存，性能很差。

### 如何保证集合不被修改？

可以使用方法 **Collections.unmodifiableCollection()** 方法来创建只读集合，任何改变集合的操作都会抛出异常。

## Iterator

```java
List<String> list = new ArrayList<>();
Iterator<String> it = list. iterator();
while(it. hasNext()){
  String obj = it. next();
  System. out. println(obj);
}
```



只能单项遍历，但是更安全，可以确保遍历元素被更改的时候抛出异常。

---

## List

### 数组和 List 相互转换

+ 数组转 List ：Arrays.asList(array)
+ List 转数组：toArray()

### ArrayList 和 LinkedList

|       ArrayList        |              LinkedList              |
| :--------------------: | :----------------------------------: |
|        动态数组        |               双向链表               |
|     随机访问效率高     |     需要移动指针从前往后依次查找     |
|     增加删除效率低     |              增删效率高              |
| 占用内存比LinkedList低 | 节点要存数据还有两个引用 pre 和 next |
|       线程不安全       |              线程不安全              |

使用场合：

+ 需要频繁读取选 ArrayList
+ 需要频繁增删选 LinkedList

### Vector

使用了 Synchronized 实现线程同步，每次扩容一倍，性能差，不建议使用。

### 多线程场景下如何使用 ArrayList？

+ 使用 Collections 的 synchronizedList 方法转换成线程安全的容器，如下

```java
List<String> synchronizedList = Collections.synchronizedList(list);
synchronizedList.add("aaa");
synchronizedList.add("bbb");

for (int i = 0; i < synchronizedList.size(); i++) {
    System.out.println(synchronizedList.get(i));
}
```

---

## Set

### HashSet 实现原理

基于 HashMap 实现，HashSet 的值放在 Map 的 key 上，value 统一为 PRESENT，不允许重复

### HashSet 和 HashMap 的区别

|                        HashMap                         |                           HashSet                            |
| :----------------------------------------------------: | :----------------------------------------------------------: |
|                     实现了Map接口                      |                        实现了Set接口                         |
|                        存键值对                        |                            存对象                            |
|                     用put添加元素                      |                       使用add添加元素                        |
|            HashMap使用键（Key）计算Hashcode            | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false |
| HashMap相对于HashSet较快，因为它是使用唯一的键获取对象 |                  HashSet较HashMap来说比较慢                  |

---

## Queue

### BlockingQueue

+ 在检索会移除一个元素的时候会等待队列变成非空，在增加元素时会等待队列中的可用空间
+ 用于实现生产者-消费者模式。实现：ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 等

---

## Map

### HashMap 的实现原理

数组+链表（**JDK1.8 进行了优化，当链表节点数量超过8个，但是数组长度小于64时首先进行扩容，否则该链表会转化为红黑树提升查询效率**，从O(n)到O(n)）

JDK1.7 头插法，JDK1.8尾插法

1. 当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中
3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。
4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。

### HashMap 的 put 方法流程

![putVal方法执行流程图](https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

### HashMap 的扩容操作

+ 每当键值对大于阈值或者初始化时，调用 resize()方法扩容，每次扩容两倍。
+ 在1.7中扩容后要重新算 Hash 值，根据 Hash 值进行分发，而在1.8中根据同一个桶的位置中判断(e.hash & oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上

### HashMap 解决哈希冲突

基础知识：

+ Hash，“散列”算法，**把任意长度的输入通过散列算法变换成固定长度的输入(散列值)**。
+ 同一散列函数得到的散列值不同则输入肯定不同，结果相同，输入不一定相同。

**哈希冲突**：两个不同的输入通过同一个散列函数计算得到相同散列值的现象。

**解决：**

1. **使用链地址法来链接拥有相同 hash 值得数据**
2. **使用两次扰动函数（hash函数）来降低哈希冲突的概率，让数据分布更均匀**
3. **引入红黑树进一步降低遍历时间复杂度**

### 为什么 HashMap 中 String、Integer 这样的包装类适合作为 K ？

答：因为这些包装类的特性可以保证 Hash 值得不可更改性，有效减少哈希冲突的几率

1. 都是 final 类型，保证 key 的不可更改性，不存在获取hash值不同的情况
2. 内部重写了 equals、hashCode方法

### 如果使用 Object 作为 HashMap 的 Key ，应该怎么办？

答：重写 hashCode 和 equals 方法

### 为什么 HashMap 不直接使用 hashCode() 处理后的哈希值作为 table 的下标？

答：hashCode()返回的是int类型，范围很大，设备上难以提供这么多存储空间，导致计算出的哈希值不在数组大小范围内，进而无法匹配存储位置。

解决：

1. HashMap 自己实现了 hash() 方法，通过两次hash来加大哈希值低位的随机性，使分布更均匀
2. 保证数组长度为2的幂次方时，使用 hash() 运算之后的值与运算(&)(数组长度-1)来获取数组下标的方式存储。

### HashMap 和 HashTable 的区别

1. 线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；**HashTable 内部的方法基本都经过 synchronized 修饰。**（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
2. 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；
3. 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。
4. **初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。
5. 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
6. 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。

### HashMap 和 TreeMap 的选择

增删查选用 HashMap，当需要对有序的 key 集合遍历时，treeMap好。

---

## ConcurrentHashMap

### ConcurrentHashMap 底层实现

**JDK1.7**

+ 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：

一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLTY0NTgzNmU3MjJjMmE5ZjkucG5n?x-oss-process=image/format,png)

1. 该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；
2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。

**JDK1.8**：

+ 在**JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现**，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWVjODU2MDM5NWUyNTU0N2EucG5n?x-oss-process=image/format,png)

### HashMap 和 ConcurrentHashMap 的区别

1. ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）
2. HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。

### ConcurrentHashMap 和 HashTable 的区别

+ 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，**数组+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
+ **实现线程安全的方式（重要）**： ① **在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。**（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :**使用 synchronized 来保证线程安全，效率非常低下**。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

对比图：

HashTable：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY?x-oss-process=image/format,png)



JDK1.7的 ConcurrentHashMap：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ?x-oss-process=image/format,png)

JDK1.8的 ConcurrentHashMap ( TreeBin红黑树节点，Node链表节点 )：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk?x-oss-process=image/format,png)

总结：concurrentHashMap 综合了 HashMap 和 HashTable，分段式锁，有细粒度。

---

## TreeMap 和 TreeSet 排序

TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。

Collections 工具类的 sort 方法有两种重载的形式，

+ 第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；

+ 第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。

------

